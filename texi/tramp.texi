\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename rcp.info
@settitle RCP User Manual
@setchapternewpage odd
@c %**end of header

@c This is *so* much nicer :)
@footnotestyle end

@c Version values, for easy modification
@c NOTE: The 'UPDATED' value is updated by the 'time-stamp' function.
@c       If you change it by hand, the modifications will not stay.
@set VERSION 1.228
@set UPDATED Tuesday, 1 February, 2000

@c Entries for @command{install-info} to use
@direntry
* RCP: (rcp).                   Emacs remote file access via rsh and rcp.
@end direntry

@c Macro to make formatting of the rcp program name consistent.
@macro rcp
@sc{rcp}
@end macro

@c Copying permissions, et al
@ifinfo
This file documents @rcp{}, a remote file editing package for Emacs and
XEmacs.
     
Copyright @copyright{} 1999 Free Software Foundation, Inc.
     
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
     
@ignore 
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).
   
@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled ``Copying'' and ``GNU General Public License'' are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
     
Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end ifinfo

@tex

@titlepage
@title @rcp User Manual
@subtitle Last updated @value{UPDATED}

@author by Daniel Pittman
@author based on documentation by Kai Gro@ss{}johann
@page

@vskip 0pt plus 1filll
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
     
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled ``Copying'' and ``GNU General Public License'' are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
     
Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.

@end titlepage
@page

@end tex

@ifnottex
@node Top
@top @rcp User Manual

This package provides remote file editing, similar to @cite{ange-ftp}.

The difference is that ange-ftp uses FTP to transfer files between the
local and the remote host, whereas @rcp uses a combination of
@command{rsh} and @command{rcp} or other work-alike programs, such as
@command{ssh}/@command{scp}.

This manual is for version @value{VERSION} of @rcp{}.

It was last updated on @value{UPDATED}.

@end ifnottex

@menu
* Copying::                     @rcp Copying conditions.
* Overview::                    What @rcp can and cannot do.

For the end user:
* Installation::                Installing @rcp with your (X)Emacs.
* Configuration::               Configuring @rcp for use.
* Usage::                       An overview of the operation of @rcp{}.
* Bug Reports::                 Reporting Bugs and Problems
* Frequently Asked Questions::  Questions and answers from the mailing list.

For the developer:
* Version Control::             The inner workings of remote version control.
* Files directories and paths::  How file names, directories and paths are mangled and managed.
* Performance::                 Caching and other performance boosters. 
@end menu


@node Copying
@chapter @rcp Copying conditions

Copyright (C) 1998, 1999 Free Software Foundation, Inc.

rcp.el is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

rcp.el is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along
with GNU Emacs; see the file COPYING. If not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
USA.


@node Overview
@chapter An overview of @rcp

After the installation of @rcp into your Emacs, you will be able to
access files on remote machines as though they were local. Access to the
remote file system for editing files, version control, and
@command{dired} are transparently enabled.

Your access to the remote machine can be with the @command{rsh},
@command{rlogin}, @command{telnet} programs or with any similar
connection method. This connection must pass ASCII successfully to be
usable but need not be 8-bit clean.

The package provides support for @command{ssh} connections out of the
box, one of the more common uses of the package. This allows relatively
secure access to machines, especially if @command{ftp} access is
disabled.

The majority of activity carried out by @rcp requires only that the
remote login is possible and is carried out at the terminal. In order to
access remote files @rcp needs to transfer their content to the local
machine temporarily.

@rcp can transfer files between the machines in a variety of ways. The
details are easy to select, depending on your needs and the machines in
question.

The fastest transfer methods rely on a remote file transfer package such
as @command{rcp}, @command{scp} or @command{rsync}. The use of these
methods is only possible if the file copy command does not ask for a
password for the remote machine.

If the remote copy methods are not suitable for you, @rcp also
supports the use of encoded transfers directly through the shell. This
requires that the @command{mimencode} or @command{uuencode} tools are
available on the remote machine.

Within these limitations, @rcp is quite powerful. It is worth noting
that, as of the time of writing, it is far from a polished end-user
product. For a while yet you should expect to run into rough edges and
problems with the code now and then.

It is finished enough that the developers use it for day to day work but
the installation and setup can be a little difficult to master, as can
the terminology.

@rcp is still under active development and any problems you encounter,
trivial or major, should be reported to the @rcp developers.
@xref{Bug Reports}.


@c For the end user
@node Installation
@chapter Installing @rcp into Emacs or XEmacs

Installing @rcp into your Emacs or XEmacs is a relatively easy
process, at least compared to rebuilding your machine from scratch ;)

Seriously though, the installation should be a fairly simple matter. 

After placing the @file{rcp.el} file in a directory in your Emacs
@var{load-path}, you need to load the @rcp library.

Because of interactions between @rcp and the @command{efs} and
@command{ange-ftp} packages, these packages @emph{must} be loaded into
Emacs @emph{before} the @rcp package is loaded.

If you do not load these packages then @rcp will fail in nasty and
irritating ways. This is not a good thing.

So, under GNU Emacs you should add the following commands to your
@file{.emacs} file:

@example
(require 'ange-ftp)     @i{; GNU Emacs ships with this}
(require 'rcp)
@end example

Under XEmacs this should be:

@example
(require 'efs)          @i{; XEmacs uses EFS rather than ange-ftp}
(require 'rcp)
@end example


@node Configuration
@chapter Configuring @rcp for use

@rcp is fully functional when it is initially installed. It is
initially configured to use the @command{rsh} and @command{rcp} programs
to connect to the remote host.

If you do not wish to use these commands to connect to the remote host,
you should change the default connection and transfer method that @rcp
uses. There are several different methods that @rcp can use to
connect to remote machines and transfer files.

There are two basic types of transfer methods, each with it's own
advantages and limitations. Both types of connection make use of a
remote shell access program such as @command{rsh}, @command{ssh} or
@command{telnet} to connect to the remote machine.

This connection is used to perform many of the operations that @rcp
requires to make the remote file system transparently accessible from
the local machine. It is only when visiting files that the methods
differ.

Loading or saving a remote file requires that the content of the file be
transfered between the two machines. The content of the file can be
transfered over the same connection used to log in to the remote machine
or the file can be transfered through another connection using a remote
copy program such as @command{rcp}, @command{scp} or @command{rsync}.

The performance of the external transfer methods is generally better
than that of the inline methods. This is caused by the need to encode
and decode the data when transferring inline.

The one exception to this rule are the @command{scp} based transfer
methods. While these methods do see better performance when actually
transferring files, the overhead of the cryptographic negotiation at
startup may drown out the improvement in file transfer times.

External transfer methods do require that the remote copy command is not
interactive --- that is, the command does not prompt you for a password.
If you cannot perform remote copies without a password, you will need to
use an inline transfer method to work with @rcp{}.

@menu
* Inline methods::              Inline methods.
* External transfer methods::   External transfer methods.
* Default Method::              Selecting a default method.
@end menu


@node Inline methods
@section Inline methods

The inline methods in @rcp are quite powerful and can work in
situations where you cannot use an external transfer program to connect.
Inline methods are the only methods that work when connecting to the
remote machine via telnet. 

These methods depend on the existence of a suitable encoding and
decoding command on remote machine. Locally, @rcp may be able to use
features of Emacs to decode and encode the files or it may require
access to external commands to perform that task.

@rcp supports the use of @command{uuencode} to transfer files. This is
@emph{not} recommended. The @command{uuencode} and @command{uudecode}
commands are not well standardized and may not function correctly or at
all on some machines, notably AIX and IRIX. These systems do not work
with @command{uuencode} at all.

In summary, if possible use the @command{mimencode} methods to transfer
the data base64 encoded. This has the advantage of using a built-in
command in every modern Emacs, improving performance.


@itemize
@item @option{rm}  ---  @command{rsh} with @command{mimencode}

Connect to the remote host with @command{rsh} and use base64 encoding to
transfer files between the machines.

This requires the @command{mimencode} command that is part of the
@command{metamail} packages. This may not be installed on all remote
machines.


@item @option{sm}  ---  @command{ssh} with @command{mimencode}

Connect to the remote host with @command{ssh} and use base64 encoding to
transfer files between the machines.

This is identical to the previous option except that the @command{ssh}
package is used, making the connection more secure.

There are also two variants, @option{sm1} and @option{sm2} that use the
@command{ssh1} and @command{ssh2} commands explicitly. If you don't know
what these are, you do not need these options.


@item @option{tm}  ---  @command{telnet} with @command{mimencode}

Connect to the remote host with @command{telnet} and use base64 encoding
to transfer files between the machines.

This requires the @command{mimencode} command that is part of the
@command{metamail} packages.


@item @option{ru}  ---  @command{rsh} with @command{uuencode}

Connect to the remote host with @command{rsh} and use the
@command{uuencode} and @command{uudecode} commands to transfer files
between the machines.


@item @option{su}  ---  @command{ssh} with @command{uuencode}

Connect to the remote host with @command{ssh} and use the
@command{uuencode} and @command{uudecode} commands to transfer files
between the machines.

As with the @command{ssh} and base64 option above, this provides the
@option{su1} and @option{su2} methods to explicitly select an ssh
version.


@item @option{tu}  ---  @command{telnet} with @command{uuencode}

Connect to the remote host with @command{telnet} and use the
@command{uuencode} and @command{uudecode} commands to transfer files
between the machines.


@end itemize



@node External transfer methods
@section External transfer methods

The external transfer methods operate through multiple channels, using
the remote shell connection for many actions while delegating file
transfers to an external transfer utility.

This saves the overhead of encoding and decoding that multiplexing the
transfer through the one connection has with the inline methods.

If you want to use an external transfer method you @emph{must} be able
to execute the transfer utility to copy files to and from the remote
machine without any interaction.

This means that you will need to use @command{ssh-agent} if you use the
@command{scp} program for transfers. If you use @command{rsync} via
@command{ssh} then the same rule must apply to that connection.

If you cannot get @command{scp} to run without asking for a password but
would still like to use @command{ssh} to secure your connection, have a
look at the @command{ssh} based inline methods.


@itemize
@item @option{rcp}  ---  @command{rsh} and @command{rcp}

This method uses the @command{rsh} and @command{rcp} commands to connect
to the remote machine and transfer files. This is probably the fastest
connection method available.


@item @option{scp}  ---  @command{ssh} and @command{scp}

Using @command{ssh} to connect to the remote host and @command{scp} to
transfer files between the machines is the best method for securely
connecting to a remote machine and accessing files.

The performance of this option is also quite good. It may be slower than
the inline methods when you often open and close small files however.
The cost of the cryptographic handshake at the start of an @command{scp}
session can begin to absorb the advantage that the lack of encoding and
decoding presents.


@item @option{rsync}  ---  @command{ssh} and @command{rsync}

Using the @command{ssh} command to connect securely to the remote
machine and the @command{rsync} command to transfer files is almost
identical to the @option{scp} method.

While @command{rsync} performs much better than @command{scp} when
transferring files that exist on both hosts, this advantage is lost if
the file exists only on one side of the connection.

The @command{rsync} based method may be considerably faster than the
@command{rcp} based methods when writing to the remote system. Reading
files to the local machine is no faster than with a direct copy. 


@end itemize


@node Default Method
@section Selecting a default method

When you select an appropriate transfer method for your typical usage
you should set the variable @var{rcp-default-method} to reflect that
choice. This variable controls which method will be used when a method
is not specified in the @rcp file path.

External transfer methods are normally preferable to inline transfer
methods, giving better performance. They may not be useful if you use
many remote machines where you cannot log in without a password.

@xref{Inline methods}.
@xref{External transfer methods}.

Another consideration with the selection of transfer methods is the
environment you will use them in and, especially when used over the
Internet, the security implications of your preferred method.

The @command{rsh} and @command{telnet} methods send your password as
plain text as you log in to the remote machine, as well as transferring
the files in such a way that the content can easily be read from other
machines.

If you need to connect to remote systems that are accessible from the
Internet, you should give serious though to using @command{ssh} based
methods to connect. These provide a much higher level of security,
making it a non-trivial exercise for someone to obtain your password or
read the content of the files you are editing.


@node Usage
@chapter Using @rcp

Once you have installed @rcp it will operate fairly transparently. You
will be able to access files on any remote machine that you can log in
to as though they were local.

Files are specified to @rcp using a formalized syntax specifying the
details of the system to connect to. This is similar to the syntax used
by the @command{EFS} and @command{ange-ftp} packages.


@menu
* Filename Syntax::             @rcp filename conventions.
* Dired::                       Dired and filename completion.
@end menu


@node Filename Syntax
@section @rcp filename conventions

To access the file <path> on the remote machine <machine> you would
specify the filename @file{/r:<machine>:<path>}. This will connect to
<machine> and transfer the file using the default method.
@xref{Default Method}.

Some examples of @rcp filenames are:

@table @file
@item /r:melancholia:.emacs
Edit the file @file{.emacs} in your home directory on the machine
@code{melancholia}.

@item /r:melancholia.danann.net:.emacs
This edits the same file, using the fully qualified domain name of
the machine.

@item /r:melancholia:~/.emacs
This also edits the same file --- the @file{~} is expanded to your
home directory on the remote machine, just like it is locally.

@item /r:melancholia:~daniel/.emacs
This edits the file @file{.emacs} in the home directory of the user
@code{daniel} on the machine @code{melancholia}. The @file{~<user>}
construct is expanded to the home directory of that user on the remote
machine.

@item /r:melancholia:/etc/squid.conf
This edits the file @file{/etc/squid.conf} on the machine
@code{melancholia}.

@end table


Unless you specify a different name to use, @rcp will use the current
local user name as the remote user name to log in with. If you need to
log in as a different user, you can specify the user name as part of the
filename.

To log in to the remote machine as a specific user, you use the syntax
@file{/r:<user>@@<machine>:/path/to.file}. That means that connecting to
@code{melancholia} as @code{daniel} and editing @file{.emacs} in your
home directory you would specify @file{/r:daniel@@melancholia:.emacs}.


It is also possible to specify other file transfer methods
(@pxref{Default Method}) as part of the filename. This is done by
replacing the initial @file{/r:} with @file{/r@@<method>:}. The user,
machine and file specification remain the same.

So, to connect to the machine @code{melancholia} as @code{daniel}, using
the @option{su} method to transfer files, and edit @file{.emacs} in my
home directory I would specify the filename
@file{/r@@su:daniel@@melancholia:.emacs}.


@node Dired
@section Dired and filename completion

@rcp works transparently with dired, enabling you to use this powerful
file management tool to manage files on any machine you have access to
over the Internet.

Filename completion also works with @rcp for files on remote machines
although there is no completion for user names or machine names at this
stage.

As filename completion needs to fetch the listing of files from the
remote machine, this feature is sometimes fairly slow. As @rcp does not
yet cache the results of directory listing, there is no gain in
performance the second time you complete filenames.

If you need to browse a directory tree, Dired is a better choice, at
present, than filename completion. Dired has it's own cache mechanism
and will only fetch the directory listing once.


@node Bug Reports
@chapter Reporting Bugs and Problems

Bugs and problems with @rcp are actively worked on by the development
team. Feature requests and suggestions are also more than welcome.

The @rcp mailing list is a great place to get information on working
with @rcp{}, solving problems and general discussion and advice on topics
relating to the package.

The  mailing list is at @email{emacs-rcp@@ls6.cs.uni-dortmund.de}.
Messages sent to this address go to all the subscribers. This is
@emph{not} the address to send subscription requests to.

For help on subscribing to the list, send mail to the administrative
address, @email{emacs-rcp-request@@ls6.cs.uni-dortmund.de}, with the
subject @samp{help}.

To report a bug in @rcp{}, you should execute @kbd{M-x rcp-bug}. This
will automatically generate a buffer with the details of your system and
@rcp version.

When submitting a bug report, please describe in excruciating detail the
steps required to reproduce the problem and, if possible, a simple
recipe that does so. This makes it easier for the development team to
locate and correct the bug.


@node Frequently Asked Questions
@chapter Frequently Asked Questions

@itemize @bullet
@item Where can I get the latest @rcp{}?

@rcp is available at
@url{ftp://ls6-ftp.cs.uni-dortmund.de/pub/src/emacs/rcp.tar.gz}.


@item I can't stop EFS starting with XEmacs

Not all the older versions of @rcp supported XEmacs correctly. The
first thing to do is to make sure that you have the latest version of
@rcp installed.

If you do, please try and find out exactly the conditions required for
the @code{EFS} handlers to fire. If you can, putting a breakpoint on
@code{efs-ftp-path} and sending in the stack trace along with your bug
report would make it easier for the developers to work out what is going
wrong.

If you feel particularly adventurous and would like a gold
star@footnote{Of course, you have to come down and visit me in Australia
to collect this, but who is counting?} and all, you might consider
debugging why @rcp actually goes wrong. A good place to start is with
@code{rcp-file-name-handler}. This really is only for the strong of
heart though.


@item File name completion does not work with @rcp

When you log in to the remote machine, do you see the output of
@command{ls} in color? If so, this may be the cause of your problems.

@command{ls} outputs @acronym{ANSI} escape sequences that your terminal
emulator interprets to set the colors. These escape sequences will
confuse @rcp however.

In your @file{.bashrc}, @file{.profile} or equivalent on the remote
machine you probably have an alias configured that adds the option
@option{--color=yes} or @option{--color=auto}.

You should remove that alias and ensure that a new login @emph{does not}
display the output of @command{ls} in color. If you still cannot use
filename completion, report a bug to the @rcp developers.


@end itemize


@c For the developer
@node Version Control
@chapter The inner workings of remote version control

Unlike EFS and ange-ftp, @rcp has full shell access to the remote
machine. This makes it possible to provide version control for files
accessed under @rcp{}.

The actual version control binaries must be installed on the remote
machine, accessible in the directories specified in
@var{rcp-remote-path}.

This transparent integration with the version control systems is one of
the most valuable features provided by @rcp{}, but it is far from perfect.
Work is ongoing to improve the transparency of the system.

@menu
* Version Controlled Files::    Determining if a file is under version control.
* Remote Commands::             Executing the version control commands on the remote machine.
* Changed workfiles::           Detecting if the working file has changed.
* Checking out files::          Bringing the workfile out of the repository.
* Miscellaneous Version Control::  Things related to Version Control that don't fit elsewhere
@end menu


@node Version Controlled Files
@section Determining if a file is under version control

The VC package uses the existence of on-disk revision control master
files to determine if a given file is under revision control. These file
tests happen on the remote machine through the standard @rcp mechanisms.


@node Remote Commands
@section Executing the version control commands on the remote machine

There are no hooks provided by VC to allow intercepting of the version
control command execution. The calls occur through the
@code{call-process} mechanism, a function that is somewhat more
efficient than the @code{shell-command} function but that does not
provide hooks for remote execution of commands.

To work around this, the functions @code{vc-do-command} and
@code{vc-simple-command} have been advised to intercept requests for
operations on files accessed via @rcp{}.

In the case of a remote file, the @code{shell-command} interface is
used, with some wrapper code, to provide the same functionality on the
remote machine as would be seen on the local machine. 


@node Changed workfiles
@section Detecting if the working file has changed

As there is currently no way to get access to the mtime of a file on a
remote machine in a portable way, the @code{vc-workfile-unchanged-p}
function is advised to call an @rcp specific function for remote files.

The @code{rcp-vc-workfile-unchanged-p} function uses the functioning VC
diff functionality to determine if any changes have occurred between the
workfile and the version control master.

This requires that a shell command be executed remotely, a process that
is notably heavier-weight than the mtime comparison used for local
files. Unfortunately, unless a portable solution to the issue is found,
this will remain the cost of remote version control.


@node Checking out files
@section Bringing the workfile out of the repository

VC will, by default, check for remote files and refuse to act on them
when checking out files from the repository. To work around this
problem, the function @code{vc-checkout} knows about @rcp files and
allows version control to occur.


@node Miscellaneous Version Control
@section Things related to Version Control that don't fit elsewhere

Minor implementation details, &c.

@menu
* Remote File Ownership::       How VC determines who owns a workfile.
* Back-end Versions::           How VC determines what release your RCS is.
@end menu


@node Remote File Ownership
@subsection How VC determines who owns a workfile

Emacs provides the @code{user-full-name} function to return the login name
of the current user as well as mapping from arbitrary user id values
back to login names. The VC code uses this functionality to map from the
uid of the owner of a workfile to the login name in some circumstances.

This will not, for obvious reasons, work if the remote system has a
different set of logins. As such, it is necessary to delegate to the
remote machine the job of determining the login name associated with a
uid.

Unfortunately, with the profusion of distributed management systems such
as @code{NIS}, @code{NIS+} and @code{NetInfo}, there is no simple,
reliable and portable method for performing this mapping.

Thankfully, the only place in the VC code that depends on the mapping of
a uid to a login name is the @code{vc-file-owner} function. This returns
the login of the owner of the file as a string.

This function has been advised to use the output of @command{ls} on the
remote machine to determine the login name, delegating the problem of
mapping the uid to the login to the remote system which should know more
about it than I do.


@node Back-end Versions
@subsection How VC determines what release your RCS is

VC needs to know what release your revision control binaries you are
running as not all features VC supports are available with older
versions of @command{rcs(1)}, @command{cvs(1)} or @command{sccs(1)}.

The default implementation of VC determines this value the first time it
is needed and then stores the value globally to avoid the overhead of
executing a process and parsing it's output each time the information is
needed.

Unfortunately, life is not quite so easy when remote version control
comes into the picture. Each remote machine may have a different version
of the version control tools and, while this is painful, we need to
ensure that unavailable features are not used remotely.

To resolve this issue, @rcp currently takes the sledgehammer
approach of making the release values of the revision control tools
local to each @rcp buffer, forcing VC to determine these values
again each time a new file is visited.

This has, quite obviously, some performance implications. Thankfully,
most of the common operations performed by VC do not actually require
that the remote version be known. This makes the problem far less
apparent.

Eventually these values will be captured by @rcp on a system by
system basis and the results cached to improve performance.


@node Files directories and paths
@chapter How file names, directories and paths are mangled and managed.

@menu
* Path deconstruction::         Breaking a path into it's components.
@end menu


@node Path deconstruction
@section Breaking a path into it's components.

@rcp filenames are somewhat different, obviously, to ordinary path
names. As such, the lisp functions @code{file-name-directory} and
@code{file-name-nondirectory} are overridden within the @rcp package.

Their replacements are reasonably simplistic in their approach. They
dissect the filename, call the original handler on the remote path and
then rebuild the @rcp path with the result.

This allows the platform specific hacks in the original handlers to take
effect while preserving the @rcp path information.


@node Performance
@chapter Caching and other performance boosters 

Remote file editing is, by it's nature, considerably slower than local
file editing. This is primarily caused by the high latency of accessing
the remote resources---files and file information.

To improve the performance of the @rcp code, local caching of
information can be used to trade away local storage space for time.


@c End of rcp.texi - the RCP User Manual
@bye

@c Local Variables:
@c eval: (add-hook 'write-file-hooks 'time-stamp)
@c time-stamp-start: "@set UPDATED "
@c time-stamp-format: "%:a, %:d %:b, %:y"
@c time-stamp-end: "$"
@c time-stamp-line-limit: 50
@c End:
